/**
 * Exploratory Debugging - Exploit Attempts
 * Tests for potential security vulnerabilities and abuse scenarios
 */

import { describe, it, expect } from "vitest";
import { checkRateLimitUnified } from "../rate-limiter-redis";
import { createRateLimitMiddleware } from "../rate-limit-middleware";

describe("Exploit Attempts - Security Vulnerabilities", () => {
  describe("Key Injection Attacks", () => {
    it("should prevent Redis key injection via userId", async () => {
      // Attacker tries to inject Redis commands via userId
      const maliciousUserIds = [
        "1; DROP TABLE users; --",
        "1\nFLUSHALL",
        "1\r\nDEL *",
        "1$(rm -rf /)",
      ];
      
      for (const userId of maliciousUserIds) {
        try {
          // Should either sanitize or throw error
          const result = await checkRateLimitUnified(userId as any, { limit: 10, windowMs: 60000 });
          // If it works, userId should be treated as number (safe)
          expect(typeof result.limit).toBe("number");
        } catch (error) {
          // Expected for invalid userIds
          expect(error).toBeDefined();
        }
      }
    });

    it("should prevent key collision via keySuffix manipulation", async () => {
      const userId = 1;
      const config = { limit: 5, windowMs: 60000 };
      
      // Attacker tries to create collisions
      const collisionAttempts = [
        ["admin", "admin:"], // Colon manipulation
        ["user", "user/"], // Slash manipulation
        ["test", "test\n"], // Newline manipulation
        ["op1", "op1\0"], // Null byte
      ];
      
      for (const [suffix1, suffix2] of collisionAttempts) {
        // Fill up limit with suffix1
        for (let i = 0; i < 5; i++) {
          await checkRateLimitUnified(userId, config, suffix1);
        }
        
        // suffix2 should have separate limit (if sanitization works)
        const result = await checkRateLimitUnified(userId, config, suffix2);
        // Should be allowed (separate operation) or sanitized to same key
        expect(result.success).toBeDefined();
      }
    });
  });

  describe("Rate Limit Bypass Attempts", () => {
    it("should prevent bypass via case manipulation", async () => {
      const userId = 1;
      const config = { limit: 3, windowMs: 60000 };
      
      // Fill up "archive"
      for (let i = 0; i < 3; i++) {
        await checkRateLimitUnified(userId, config, "archive");
      }
      
      // Try different cases
      const bypassAttempts = ["Archive", "ARCHIVE", "ArChIvE"];
      
      for (const attempt of bypassAttempts) {
        const result = await checkRateLimitUnified(userId, config, attempt);
        // Should either be separate (case-sensitive) or collide (case-insensitive)
        // Main thing: should not allow unlimited bypass
        expect(result.success).toBeDefined();
      }
    });

    it("should prevent bypass via whitespace manipulation", async () => {
      const userId = 1;
      const config = { limit: 3, windowMs: 60000 };
      
      // Fill up "delete"
      for (let i = 0; i < 3; i++) {
        await checkRateLimitUnified(userId, config, "delete");
      }
      
      // Try with whitespace
      const bypassAttempts = [" delete", "delete ", " delete ", "\tdelete", "delete\n"];
      
      for (const attempt of bypassAttempts) {
        const result = await checkRateLimitUnified(userId, config, attempt);
        // Should be sanitized
        expect(result.success).toBeDefined();
      }
    });

    it("should prevent bypass via unicode normalization", async () => {
      const userId = 1;
      const config = { limit: 3, windowMs: 60000 };
      
      // Fill up "star"
      for (let i = 0; i < 3; i++) {
        await checkRateLimitUnified(userId, config, "star");
      }
      
      // Try unicode variations
      const bypassAttempts = [
        "star\u200B", // Zero-width space
        "star\uFEFF", // Zero-width no-break space
        "star\u200C", // Zero-width non-joiner
      ];
      
      for (const attempt of bypassAttempts) {
        const result = await checkRateLimitUnified(userId, config, attempt);
        // Should be sanitized
        expect(result.success).toBeDefined();
      }
    });
  });

  describe("Resource Exhaustion Attacks", () => {
    it("should handle memory exhaustion via many operations", async () => {
      const userId = 1;
      const config = { limit: 10, windowMs: 60000 };
      
      // Create 10000 different operation names
      const operations = Array.from({ length: 10000 }, (_, i) => `op${i}`);
      
      // Each should work (separate limits)
      const results = await Promise.all(
        operations.slice(0, 100).map(op => // Limit to 100 for test performance
          checkRateLimitUnified(userId, config, op)
        )
      );
      
      const allowed = results.filter(r => r.success).length;
      expect(allowed).toBe(100);
      
      // Memory should be managed (cleanup should handle this)
    });

    it("should handle CPU exhaustion via rapid requests", async () => {
      const userId = 1;
      const config = { limit: 100, windowMs: 60000 };
      
      // Fire 1000 rapid requests
      const startTime = Date.now();
      const promises = Array.from({ length: 1000 }, () =>
        checkRateLimitUnified(userId, config, "cpu-test")
      );
      
      const results = await Promise.all(promises);
      const endTime = Date.now();
      
      // Should complete in reasonable time (< 5 seconds)
      expect(endTime - startTime).toBeLessThan(5000);
      
      // Should only allow limit
      const allowed = results.filter(r => r.success).length;
      expect(allowed).toBeLessThanOrEqual(config.limit);
    });
  });

  describe("Configuration Manipulation", () => {
    it("should prevent bypass via config manipulation", async () => {
      // Attacker tries to manipulate config
      const maliciousConfigs = [
        { limit: -1, windowMs: 60000 }, // Negative limit
        { limit: 0, windowMs: 60000 }, // Zero limit
        { limit: Number.MAX_SAFE_INTEGER, windowMs: 60000 }, // Very large limit
        { limit: 10, windowMs: -1000 }, // Negative window
        { limit: 10, windowMs: 0 }, // Zero window
      ];
      
      for (const config of maliciousConfigs) {
        try {
          const result = await checkRateLimitUnified(1, config as any);
          // Should either work (with validation) or throw error
          expect(result).toBeDefined();
        } catch (error) {
          // Expected for invalid configs
          expect(error).toBeDefined();
        }
      }
    });

    it("should validate middleware config at creation time", () => {
      // Should throw error for invalid config
      expect(() => {
        createRateLimitMiddleware({ maxRequests: -1, windowMs: 1000 });
      }).toThrow();
      
      expect(() => {
        createRateLimitMiddleware({ maxRequests: 10, windowMs: 500 });
      }).toThrow();
    });
  });
});

describe("Exploit Attempts - Data Integrity", () => {
  it("should prevent data corruption via concurrent modifications", async () => {
    const userId = 1;
    const config = { limit: 10, windowMs: 60000 };
    
    // Multiple concurrent requests should maintain consistency
    const promises = Array.from({ length: 50 }, () =>
      checkRateLimitUnified(userId, config, "concurrent")
    );
    
    const results = await Promise.all(promises);
    const allowed = results.filter(r => r.success).length;
    
    // Should be exactly limit, not more
    expect(allowed).toBe(config.limit);
  });

  it("should prevent race condition exploits", async () => {
    const userId = 1;
    const config = { limit: 5, windowMs: 60000 };
    
    // Rapid concurrent requests to exploit race conditions
    const promises = Array.from({ length: 100 }, () =>
      checkRateLimitUnified(userId, config, "race")
    );
    
    const results = await Promise.all(promises);
    const allowed = results.filter(r => r.success).length;
    
    // Should not exceed limit even with race conditions
    expect(allowed).toBeLessThanOrEqual(config.limit);
  });
});

